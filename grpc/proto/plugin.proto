syntax = "proto3";
package proto;
option go_package = ".;proto";

service TailpipePlugin {
  rpc GetSchema(GetSchemaRequest) returns (GetSchemaResponse);
  rpc AddObserver(AddObserverRequest) returns (stream Event);
  rpc Collect(CollectRequest) returns (Empty);
 }

message AddObserverRequest{}

message CollectRequest {
  // unique identifier for collection execution this will be used as base for the filename fo the resultiung JSONL files
  string execution_id = 1;
//  dest path for jsonl files
  string output_path= 2;

  string collection_type = 3;
  // raw hcl for collection specific config
  bytes collection_config = 4;
  string source_type = 5;
  // raw hcl for source specific config
  bytes source_config = 6;

  //
  // this is json encoded data that can be used to resume a collection
  // the plugin will know how to de
  bytes paging_data = 7;
}

message Empty {}

message GetSchemaRequest {
}

message GetSchemaResponse {
  // Map of schemas keyed by collection name
  map<string, Schema> schemas = 1;
}

// schema
message Schema {
  // Map of source field name to column name and type
  repeated ColumnSchema columns = 1;
}

message ColumnSchema {
  // The type of the column - must be a valid DuckDB type
  string type = 1;
  // The name of the source field
  string source_name = 2;
  // The name of the column
  string column_name = 3;
  // child fields (for a struct
  repeated ColumnSchema child_fields = 4;
}


// events

// Define the Event message with oneof and enum
message Event {
  oneof event {
    EventStarted started_event = 1;
    EventChunkWritten chunk_written_event = 2;
    EventComplete complete_event = 3;
    EventError error_event = 4;
  }
}

message EventStarted {
  string execution_id = 1;
}
message EventChunkWritten {
  string execution_id = 1;
  int32 chunk_number = 2;
  bytes paging_data = 3;
}
message EventError {
  string execution_id = 1;
  string error = 2;
}

message EventComplete {
  string execution_id = 1;
  int64 row_count=2;
  int32 chunk_count=3;
  string error = 4;
}